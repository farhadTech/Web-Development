<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Visualization with BFS and DFS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 1px solid #333;
            margin-top: 20px;
            cursor: pointer;
        }
        .node {
            background-color: #3498db;
            color: #fff;
            border: 2px solid #2980b9;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-size: 14px;
            position: absolute;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .node.selected {
            background-color: #2ecc71;
            border-color: #27ae60;
        }
        .node.visited {
            background-color: #9b59b6;
            border-color: #8e44ad;
        }
        .node.start {
            background-color: #f39c12;
            border-color: #e67e22;
        }
        .node.end {
            background-color: #e74c3c;
            border-color: #c0392b;
        }
        .node.current {
            background-color: #f1c40f;
            border-color: #f39c12;
        }
        .edge {
            position: absolute;
            border: 1px solid #ccc;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Graph Visualization with BFS and DFS</h1>
        <canvas id="graphCanvas" width="800" height="500"></canvas>
        <div>
            <label for="nodeName">Node Name:</label>
            <input type="text" id="nodeName" placeholder="Node name">
            <button onclick="addNode()">Add Node</button>
            <button onclick="clearCanvas()">Clear Canvas</button>
            <button onclick="runBFS()">Run BFS</button>
            <button onclick="runDFS()">Run DFS</button>
        </div>
    </div>

    <script>
        let nodes = [];
        let edges = [];
        let canvas = document.getElementById('graphCanvas');
        let ctx = canvas.getContext('2d');
        let radius = 20;
        let nodeCount = 0;
        let selectedNode = null;
        let startNode = null;
        let endNode = null;
        let dragNode = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function addNode() {
            let nodeName = document.getElementById('nodeName').value.trim();
            if (!nodeName) {
                alert('Please enter a node name.');
                return;
            }

            let newNode = {
                id: nodeCount++,
                name: nodeName,
                x: Math.random() * (canvas.width - radius * 2) + radius,
                y: Math.random() * (canvas.height - radius * 2) + radius,
                neighbors: []
            };

            nodes.push(newNode);
            redrawCanvas();
        }

        function clearCanvas() {
            nodes = [];
            edges = [];
            startNode = null;
            endNode = null;
            redrawCanvas();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            edges.forEach(edge => drawEdge(edge));

            nodes.forEach(node => drawNode(node));
        }

        function drawNode(node) {
            let className = 'node';
            if (node === selectedNode) {
                className += ' selected';
            } else if (node === startNode) {
                className += ' start';
            } else if (node === endNode) {
                className += ' end';
            }
            ctx.beginPath();
            ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = getNodeColor(node);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = getBorderColor(node);
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '14px Arial';
            ctx.fillText(node.name, node.x, node.y);
        }

        function drawEdge(edge) {
            let startNode = nodes.find(node => node.id === edge.start);
            let endNode = nodes.find(node => node.id === edge.end);
            ctx.beginPath();
            ctx.moveTo(startNode.x, startNode.y);
            ctx.lineTo(endNode.x, endNode.y);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function getNodeColor(node) {
            if (node.visited) {
                return '#9b59b6'; // Purple for visited nodes
            }
            return '#3498db'; // Blue for default nodes
        }

        function getBorderColor(node) {
            if (node === selectedNode) {
                return '#27ae60'; // Green for selected node
            } else if (node === startNode) {
                return '#e67e22'; // Orange for start node
            } else if (node === endNode) {
                return '#c0392b'; // Red for end node
            }
            return '#2980b9'; // Dark blue for default node border
        }

        canvas.addEventListener('mousedown', function(e) {
            let mouseX = e.clientX - canvas.getBoundingClientRect().left;
            let mouseY = e.clientY - canvas.getBoundingClientRect().top;

            // Check if any node is clicked
            nodes.forEach(node => {
                let dx = mouseX - node.x;
                let dy = mouseY - node.y;
                if (dx * dx + dy * dy < radius * radius) {
                    if (selectedNode === null) {
                        selectedNode = node;
                    } else {
                        if (selectedNode.id !== node.id) {
                            addEdge(selectedNode.id, node.id);
                        }
                        selectedNode = null;
                    }
                }
            });

            redrawCanvas();
        });

        canvas.addEventListener('mousemove', function(e) {
            if (dragNode) {
                let mouseX = e.clientX - canvas.getBoundingClientRect().left;
                let mouseY = e.clientY - canvas.getBoundingClientRect().top;
                dragNode.x = mouseX - dragOffsetX;
                dragNode.y = mouseY - dragOffsetY;
                redrawCanvas();
            }
        });

        canvas.addEventListener('mouseup', function(e) {
            dragNode = null;
        });

        function addEdge(startNodeId, endNodeId) {
            edges.push({ start: startNodeId, end: endNodeId });
            let startNode = nodes.find(node => node.id === startNodeId);
            let endNode = nodes.find(node => node.id === endNodeId);
            startNode.neighbors.push(endNodeId);
            endNode.neighbors.push(startNodeId);
        }

        async function runBFS() {
            clearNodeState();
            if (!startNode) {
                alert('Select a start node first.');
                return;
            }
            await bfs(startNode);
        }

        async function bfs(start) {
            let queue = [start];
            start.visited = true;

            while (queue.length > 0) {
                let currentNode = queue.shift();
                currentNode.visited = true;
                redrawCanvas();
                await sleep(500); // Adjust speed here (milliseconds)

                currentNode.neighbors.forEach(neighborId => {
                    let neighborNode = nodes.find(node => node.id === neighborId);
                    if (!neighborNode.visited) {
                        queue.push(neighborNode);
                        neighborNode.visited = true;
                        redrawCanvas();
                    }
                });
            }
        }

        async function runDFS() {
            clearNodeState();
            if (!startNode) {
                alert('Select a start node first.');
                return;
            }
            await dfs(startNode);
        }

        async function dfs(node) {
            node.visited = true;
            redrawCanvas();
            await sleep(500); // Adjust speed here (milliseconds)

            for (let neighborId of node.neighbors) {
                let neighborNode = nodes.find(n => n.id === neighborId);
                if (!neighborNode.visited) {
                    await dfs(neighborNode);
                }
            }
        }

        function clearNodeState() {
            nodes.forEach(node => {
                node.visited = false;
            });
            redrawCanvas();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
